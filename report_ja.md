---
layout: post 
title: WebRTCセキュリティレポート
---

## あらまし

WebRTC(Web Real-Time Communication)は、Webアプリケーション技術の昨今のトレンドの一つだ。WeBRTCを利用すると、プラグイン無しで、また他の要件無しでリアルタイムコミュニケーションを実現できる。だが、オープンソースとしての性質により、WebRTCを採用しようとする人がセキュリティ上の不安を覚えることもあるだろう。本レポートはWebRTCのセキュリティについて明らかにし、他の技術と比較してWebRTCのセキュリティが優れていることを実証する。

## 1. イントロダクション

WebRTCはオープンソースのWebベースの技術であり、ユーザがリアルタイムメディア通信を、プラグイン無しで実現することができる技術だ。適切なブラウザを利用すれば、ウェブサイトをブラウズするだけで、他者に発信して通話することができる。

WebRTCの主なユースケースは以下の通り：

- リアルタイムの音声/映像通信
- ウェブ会議
- P2Pでのデータ送受信

他のリアルタイムシステム(例えばSIP)と異なり、WebRTCの通信は、JavaScriptのAPIを通じてWebサーバによって制御される。

プラグイン無しで、音声映像の通信を可能にするという点は非常に興味深い。
だが、その性質自体がセキュリティに関する不安を引き起こしている。
また、エンドユーザ・通信事業者・サードパーティの両方にとって
信頼できる通信を提供できるかどうかについても、不安がある。

本レポートではこれらのトピックについて述べ、さらにWebRTCが全ての例に提供するセキュリティについて防衛方法について調査する。ただし、このレポートではネイティブアプリケーションは扱わない。

## 2. WebRTCアーキテクチャの概要

WebRTCはP2Pのトポロジ形式で、ピア間のメディア通信を実現する。
WeBRTCはユーザのブラウザに実装されており、追加のソフトウェアを必要としない。
ピア間の通信が始まる前には、「シグナリング」と呼ばれるメタ情報の交換が必要だ。
このシグナリングプロセスは、通信の開始時に利用され、ピア間の接続確立を実現する。
★unfamiliar parties ってどう訳す？

図1に示すように、シグナリングプロセスは中継サーバを経由して実現される。

                    +----------------+
                    |                |
                    |    Signaling   |
                    |    Server      |
                    |                |
                    +----------------+
                      ^           ^
                     /             \
         Signaling  /               \   Signaling
                   /                 \
                  /                   \
                 v                     v
               JS API                  JS API
          +-----------+             +-----------+
          |           |    Media    |           |
          |  Browser  |<----------->|  Browser  |
          |           |             |           |
          +-----------+             +-----------+
              Alice                      Bob

図1. WebRTCのシンプルなトポロジ例

シグナリングプロトコルはWebRTCで仕様規定されているわけではない。
これは開発者が自身の選択でプロトコルを選べるようにしているためだ。
ユースケースやシナリオに適したアプリケーションを柔軟に作れる。

### WebRTCの通信はどのように動作するのか？

WebRTCは3つのAPIから成っており、それぞれがリアルタイム通信を実現するために、特定の機能を実行する。
これらのAPIは以降で簡単に解説する。それぞれのプロトコルの技術的な詳細、実装については、このレポートで扱わないが、関連するドキュメントはオンラインで簡単に見つけられる。

### getUserMedia

WebRTC登場以前は、音声や映像の取得にはサードパーティのプラグイン（例えばFlashやSilverlight）が必要だった。だが、HTML5の時代になり、多くのデバイスについて直接アクセスする手段が出現し、JavaScriptのAPIがハードウェアの能力を利用できるようにあった。

getUserMediaはそのようなAPIの一つで、ブラウザからカメラ・マイクへアクセスするためのAPIだ。WebRTCで利用されるAPIだが、このAPIはHTML5の一つとして提供されている。

### RTCPeerConnection

RTCPeerConnectionは、WebRTC仕様として規定される2つのAPIのうちの1つだ。
RTCPeerConnectionインターフェースは、WebRTCの通信を示しており、
2つのピア間の効率的なデータ転送に利用される。

発信者がある着信先に通信を開始する場合、ブラウザはRTCPeerConnectionのインスタンスをまず作成する。このとき、自身が作成するSDP(Session Description Protocol)を、通信相手と交換する。
受信側でも、SDPを作成し発信側に応答する。SDPはNAT越えのためのICEワークフロの一部として利用される。

コネクションが確立したら、RTCPeerConnectionはブラウザ間で音声・映像のデータをビットストリームとして送れるようになる。

究極的には、RTCPeerConnectionAPIがP2Pコネクションのライフサイクルの管理の責務を担い、
接続確立・状態管理を一つのインターフェースで管理できるようにしている。

RTCPeerConnectionは2つの特色がある：

- 2つのブラウザ間のP2P接続
- UDP/IPの利用、すなわちTCP/IPの場合と異なりパケットの到達保証が無いが、オーバーヘッドはかなり小さい
  - (ある程度のデータのロスを許容することで、リアルタイム通信に集中できる)

### RTCDataChannel

RTCDataChannelがWebRTC仕様として規定されるAPIのうちのもう1つであり、
ピア間の任意のアプリケーションデータの交換に利用されるコミュニケーションチャネルである。
言い換えれば、ピア間のデータ転送に利用される。

既にデータ転送するための仕組みは他にもあり、例えばWebSocketやServer Sent Eventsがある。
しかし、これらはピア間のデータ転送というよりも、サーバクライアント型向けのデザインである。
RTCDataChannelはWebSocketに似てているが、P2Pの形式で利用される。
また、RTCDataChannelは、トランスポートの特性をカスタマイズ可能といった特性がある。

## 2.1. WebRTCを支える技術群

開発者が利用するWebRTCのAPIは大きく3つあるが、配下にはそのAPIの支える多くの技術がある。

(TODO: 図を後で入れる)

ICE、STUN、TURNはP2Pの接続を確立・維持に利用されている。
DTLSはピア間のデータ転送をセキュアにするために利用されており、
暗号化はWebRTCで必須となっている機能だ。
最後に、SCTPと　★誤記っぽいので後でもっかい

- 異なるシステム間でアプリケーションプロトコルを多重化するのに利用される
- 輻輳制御と流量制御を提供している
- 信頼性のある転送
- UDPの上に構築されている

### SDP: Session Description Protocol (セッション記述プロトコル)

SDP(Session Description Protocol)は、セッション開始を宣言・維持するための標準的な方法で、
記述的なプロトコルだ。また、SDPはマルチメディアセッションの開始等のタスクも担う。
SDPは、ブラウザの能力とプリファレンスをテキストベースで表現しており、
以下の情報を含む：

- メディア能力(音声、映像)、コーデック
- IPアドレスとポート番号
- P2Pデータ転送プロトコル(音声映像なら、WebRTCではSecure RTP)
- 利用可能帯域
- セッション属性(名前、識別子、開始終了時間)
  - ほとんどWebRTCでは利用されていないが…
- その他のメタデータ

今日のSDPのユースケースの中で、SDPがもっとも利用されているのはSIP、RTP(Real-Time Transport Protocol)、RTSP（Real-Time Streaming Protocol）だ。★

### ICE: Interactive Connectivity Establishment

シグナリングは、メタデータを交換する前に最初に中継サーバを必要とする。
メタデータ交換が完了すれば、WebRTCはP2Pの直接接続を試みる。
このプロセスは、ICEフレームワークを通じて実現される。

ICEは、インターネット上でピア間の接続を確立するのに使われるフレームワークのことだ。
WebRTCはP2Pによる直接通信をするが、実際には広く利用されている
NAT(Network Address Translation)のせいで、
2つのピアが接続確立するのは難しい。

32ビットのIPv4アドレスは広く利用されているので、インターネットから
直接到達可能はユニークなIPv4アドレスをネットワーク機器が持つのは難しい。
NATは、プライベートIPをパブリックIPに、内側から外側へリクエストが出るときに変換する。
同様に反対の場合は、内側のネットワークで適切にルーティングされるように、
パブリックIPからプライベートIPへ変換する。
その結果、プライベートIPを通信相手のピアと交換しても、
ピア同士で接続するには十分な情報とはいえない。
ICEは、この難しさを克服するために、またピアに対する最適な経路を見つけるために利用される。

可能な限り並列に接続の可能性を試すことで、ICEは最も効率的なパスを選択できる。
ICEは最初に、OS（ネットワークインターフェース）から得られたホストアドレスを利用して、
接続確立を試みる。もし失敗したら（NATの背後にいるっため）ICEは、STUNサーバを利用して
NAT外部のアドレスを取得して接続確立を試みる。
それもまた失敗したら、最後のフォールバックとしてTURNサーバを利用する。

ICE候補はテキスト形式で表現され、ICE候補は優先度によってソートされている。
ICEは以下のいずれかを選択する。

- 直接P2P接続
- STUNを使って、NAT越えを実現したP2P接続
- TURNを中継サーバとして利用した接続

これらの候補の中で、もっともオーバヘッドが少ないものが選択される。

### STUN: Session Traversal Utilities for NAT

P2P通信を実施するために、発信側・着信側はそれぞれ、
自身に割り当てられたIPアドレスとポート番号を必要とする。
WebRTCの通信が確立する前には、ある一定の情報交換が必要ということだ。

STUNサーバは、パブリックIPを取得するために利用される。
また、ICEフレームワークの接続処理の中でも参照される。
STUNサーバは典型的にはパブリックにアクセス可能な存在であり、
WebRTCのアプリケーションから自由に利用される。

### TURN: Traversal Using Relays around NAT

P2Pによる接続確立が失敗すると、フォールバックとしてTURNサーバ経由の接続が利用される。
ピア間のトラフィック転送を中継することで、WebRTCによる通信が担保される。
しかし、メディアの品質・レイテンシが低下する可能性もありうる。

ユーザの環境にかかわらず、TURNサーバはコール確立を高い可能性でできるように担保できる。
データは中継サーバを通じて送られるので、サーバ側での帯域も消費される。
もし多くの通信が同時に発生すると、かなりの量の帯域が消費される。

サーバ自体は典型的には自由にアクセスされないようにする。
また、アプリケーション提供者によって提供されるべき（またはレンタルするべき）だ。

## 3. ブラウザベースのセキュリティ考察

リアルタイプアプリケーションがセキュリティの危険にあう方法は、
ネットワーク側およびユーザ側のどちらにも存在している。
このようなセキュリティリスクは、データ通信・メディア通信の両方のデータ転送を利用する
どんなアプリケーションにも当てはまる。

WebRTCは、他のリアルタイム通信アプリケーションと異なる。
それは、新規にWebRTCを利用する開発者にとって、セキュリティの危険を回避しつつ、
強固で信頼性のある基盤を利用することができるためだ。
本レポートでは、WebRTCがどのようにセキュリティリスクに対処しているか議論する。

### ブラウザ信頼モデル(Browser Trust Model)

WebRTCアーキテクチャは、セキュリティの観点から言えば、信頼の階層の中に
ネットワークリソースが存在することを想定している。
ユーザから見れば、ブラウザ（ユーザクライアント）が、全てのWebRTCセキュリティの基盤であり、
TCB(Trusted Computing Base、信頼性のある基盤)として振る舞う。

ブラウザの仕事はインターネットへのアクセスを可能にする一方で、
ユーザにとって十分なセキュリティ防御を提供する。
WebRTCｃのセキュリティ要件は、この上に構築されている。
つまり、ユーザがアクセスする全てのWebRTCアプリケーションおよびコンテンツは、
全てブラウザといポータルを通じてアクセスされるということだ。

サーバから提供されるHTMLとJavaScriptはブラウザに様々な動作をさせる一方で、
ブラウザはそれらのスクリプトをサンドボックス上に隔離している。
サンドボックスはスクリプトをスクリプト間で隔離、
またユーザのコンピュータからも隔離する。
一般的に、スクリプトは同じドメインからのみしかリソースを扱えない。
もっと具体的に言えば、 同じ"origin"ということだ。

ブラウザはユーザが望むセキュリティポリシを全て強制し、
またサードパーティの検証をする最初のステップでもある。
検証された全てのエンティティは、ブラウザにチェックされたという証明を持つ。

もし、ユーザが信頼できるブラウザを選んだなら、
残りのプロセスとして、全てのWebRTCの通信は「安全」と考えられ、
WebRTCの技術で提供されるセキュリティアーキテクチャに従うことになる。
しかし、もしブラウザが「信頼できる」という点に疑いがあるなら、
（たとえば、信頼できない場所からダウンロードした場合等）
WebRTCのアプリケーションは影響を受けている可能性があり、
安全でないかもしれない。

言い換えれば、ユーザに提供されるWebRTCのセキュリティのレベルは、
ブラウザの信頼に直接影響されるということだ。

### 同一オリジンポリシー (SOP: Same Origin Policy)

Webページがロードされる場合に、
全てのWebページのリソースはWebサーバから取得されるという点は、
DOMの基本的な観点の一つだ。
リソースの取得は、ブラウザがリロードされた場合や、
Webページが内包するスクリプトによって発行されるリクエストを通じて実施される。
そのようなスクリプトは、XMLHttpRequest APIを利用するが、
任意のサーバに対してリクエストを送れるわけではない。
リクエストはスクリプトを入手した「オリジン」と同一でなければならない。
「オリジン」は、URIスキーマ、ホスト名、ポート番号から構成される。
これら全ての制限が、「同一オリジンポリシ」（SOP、Same Origin Policy)と定義される。

SOPは、スクリプトの実行をオリジンごとのサンドボックスに隔離する。
そのため、SOPは異なるオリジン・iframeと情報を交換するのを禁じている。
同一オリジンから提供されるWebページとスクリプトは、
それぞれのJS変数から相互に影響される。
そのようなオリジンが、サンドボックスの単位の基本だ。

サンドボックスでの実行はオリジンを基本とするが、
エンドユーザはクレデンシャルの誤用からも守られている。
例えば、ソーシャルネットワークを利用する場合に、安全に使いたいと思うのは普通であり、
その際、広告パネルのスクリプト実行は避けたいし、ログイン情報を盗まれないようにしている。

同様に、Webページのサーバもユーザのブラウザからの攻撃から守ることができる。
もし、そのようなガードが無ければ、DoS攻撃によって、リソースを乱用できることになる。

#### SOPをバイパスする

SOPは一般的に、ユーザとWebサーバの両方にとって非常には重要なセキュリティ機能だが、
ある特定のWebアプリにとって不利な点でもある。
サイト間の連携をする場合は、相互に同意が必要でありかつ方法は限られる、
その方法はたしかに存在している。

W3Cのクロスオリジンリソースシェアリング(CORS, Cross-Origin Resource Sharing)は、
この問題に対する回答の一つだ。
CORSにより、ブラウザはスクリプトが希望する任意のサーバに対して、
実際にアクセスをしてよいか判断するためにコンタクトする。
もし、クロスオリジンのリクエストが安全に許可されるなら、
特定のリクエストは許可して、それ以外のリクエストは拒否するように動作する。

Webソケットは同様の機能を提供するもう一つのオプションだが、
隔離されているHTTPのリクエストとは異なり、チャネルに対して透過性がある。
Webソケットのコネクションがひとたび確立してしまえば、
スクリプトから自由にトラフィックを転送できるし、リソースも扱える。
また、一連のHTTPリクエスト/レスポンスのようなフレームも扱える。

どちらのケースでも、最初の認証の段階によって、
小おtなるオリジンからの任意のデータ転送を阻止できる。

## 4. WebRTCのセキュリティ考察













































